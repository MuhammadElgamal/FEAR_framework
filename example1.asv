clc; clear all; close all;
%% Example 1 Evaluation
% nodes are ordered begining from source in anticlock wise direction in
% Fig. 2
source=7; sink=10;            % Defining source and sink nodes 
directed=true;                % Defining the typr of network whether directed or not
nodes_neglected=true;         % if nodes are neglected then they are assumed to be prefectly reliable
terminals_excluded=true;      % terminals are not included in the minimal path lines
 
source_nodes=[7 8 8 9 7 9 ];    % defines all possible arcs
target_nodes=[8 10 9 8 9 10];   
net=reliability_net(source, sink, directed, nodes_neglected, ...
        terminals_excluded, source_nodes, target_nodes);
% if not specificed the number of units per components is presumed to be 1
plot(net);
%% _______________ Entering Maximal Capacity for each element _______________
% Taking the capacity probability distibution of each arc
CP=cell(1,6);           
CP{1}=[0.05 0.1 0.25 0.6]; 
CP{2}=[0.1 0.3 0.6];       
CP{3}=[0.1 0.9];           
CP{4}=CP{3};
CP{5}=CP{3};
CP{6}=[0.05 0.25 0.7];

net.take_capacity (CP);
net.flow_constraints={'flow=demand', 'less than Lj', 'maximal capacity constraint'};
%% Evaluating Reliability
figure;
% Check all possible constraints and make sure they are cleared
plot_curve = true;  maximal_cost = []; maximal_error = []; compute_fast = false;
net.evaluate_reliability(plot_curve, maximal_cost, maximal_error, compute_fast);
disp(net);
%% Reporting Output
required_demand = 3;
disp("_____________________________");
mc = cellfun(@(x) length(x)-1, net.CP);
disp("STEP 0");
fprintf('Source node = %d\nTarget node = %d\n', source, sink);
fprintf('Required Demand [d] = %d\n', required_demand);
fprintf('Maximal Capacity [C] = (%s)\n', num2str(mc));
fprintf('Number of nodes [n] = %d\nNumber of arcs [a] = %d\n',length(unique([source_nodes, target_nodes])), length(source_nodes));
if net.directed
    disp('Arcs are unidirectional');
else
    disp('Arcs are bidirectional');
end
if net.nodes_neglected
    disp('Nodes are perfectly reilable');
elseif net.terminals_excluded
    disp('All nodes are unreilable (has capacity distribution) EXCEPT source and target nodes');
else
    disp('All nodes are unreilable (has capacity distribution)');
end
disp("----");
disp('Capacity Distribution');
disp("demand");
print_row(0: max(mc), max(mc)+1);
disp("Capacity");
for i = 1: size(net.CP)
    print_row(net.CP{i}, max(mc) + 1);
end

%% ---------------------
disp("_____________________________");
disp("STEP 1");
disp("Minimal Paths");
cellfun(@(x) disp(x), net.P.components);
%---------------------
disp("_____________________________");
disp("STEP 2");
fprintf('Constraints\n');
cellfun(@(x) fprintf("'%s'\n",x), net.flow_constraints);
disp("----");
[lb, ub, A, b, C, d]=generate_constraints(net, required_demand, maximal_cost, maximal_error);
disp("The order of the columns is same as order of minimal paths shown earlier")

fprintf("Lower bound for flow = (%s) \nUpper bound for flow = (%s)\n", num2str(lb), num2str(ub));
disp("----");

fprintf("Inequality Constraints for flow A F' <= b (F is a row vector)\n");
disp("A = ");
for i = 1: size(A,1)
    fprintf("%s\n", num2str(A(i,:)));
end
fprintf("\nb = \n");
for i = 1: size(A,1)
    fprintf("%s\n", num2str(b(i,:)));
end
disp("----");

fprintf("Equality Constraints for flow C F' = d' (F is a row vector)\n");
disp("C = ");
for i = 1: size(C,1)
    fprintf("%s\n", num2str(C(i,:)));
end
fprintf("\nd' = \n");
fprintf("%s\n", num2str(d'));

%------------------ 
disp("_____________________________");
disp("STEP 3");
disp("Acceptable flow vectors (row vectors)");

%% Functions
function print_row(x, l)
for i = 1: length(x)
    fprintf("%-10.4f",x(i));
end
for i = length(x)+1:l
    fprintf("%-10s","-");
end
fprintf("\n");
end

